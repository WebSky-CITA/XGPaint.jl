var documenterSearchIndex = {"docs":
[{"location":"rsz/#The-Relativistic-Sunyaev–Zeldovich-Effect","page":"Relativistic Sunyaev–Zeldovich Effect","title":"The Relativistic Sunyaev–Zeldovich Effect","text":"","category":"section"},{"location":"rsz/","page":"Relativistic Sunyaev–Zeldovich Effect","title":"Relativistic Sunyaev–Zeldovich Effect","text":"An example from Kuhn et al. (in prep). Begin with the tSZ example but on a smaller tile,","category":"page"},{"location":"rsz/","page":"Relativistic Sunyaev–Zeldovich Effect","title":"Relativistic Sunyaev–Zeldovich Effect","text":"using Unitful, UnitfulAstro, XGPaint, Plots, Pixell\nimport PhysicalConstants.CODATA2018 as constants\n\nM_200 = 1e15 * XGPaint.M_sun\nz = 0.4\nθ = 60*4.84814e-6\n\nbox = [-30   30;           # RA\n       -30   30] * Pixell.arcminute  # DEC\nshape, wcs = geometry(Pixell.CarClenshawCurtis, box, 1 * Pixell.arcminute)\nworkspace = profileworkspace(shape, wcs)\ny_model_interp = XGPaint.load_precomputed_battaglia();\nnothing # hide","category":"page"},{"location":"rsz/","page":"Relativistic Sunyaev–Zeldovich Effect","title":"Relativistic Sunyaev–Zeldovich Effect","text":"tsz_snap = Enmap(zeros(shape), wcs)\nmass_in_Msun = ustrip(M_200 / XGPaint.M_sun)\npaint!(tsz_snap, workspace, y_model_interp, [mass_in_Msun], [z], [0.0], [0.0])\nplot(log10.(tsz_snap))","category":"page"},{"location":"rsz/","page":"Relativistic Sunyaev–Zeldovich Effect","title":"Relativistic Sunyaev–Zeldovich Effect","text":"tsz_snap = Enmap(zeros(shape), wcs)\nmass_in_Msun = ustrip(M_200 / XGPaint.M_sun)\npaint!(tsz_snap, workspace, y_model_interp, [mass_in_Msun], [z], [0.0], [0.0])\nplot(log10.(tsz_snap))","category":"page"},{"location":"rsz/","page":"Relativistic Sunyaev–Zeldovich Effect","title":"Relativistic Sunyaev–Zeldovich Effect","text":"i_ctr, j_ctr = round.(Int, sky2pix(tsz_snap, 0.0, 0.0))\nras = [pix2sky(tsz_snap, i, j_ctr)[1] for i in 1:size(tsz_snap,1)]\nplot(ras, log10.(tsz_snap[:,j_ctr]), label=\"tSZ\", xlabel=\"RA [rad]\", ylabel=\"log10 y\")","category":"page"},{"location":"rsz/","page":"Relativistic Sunyaev–Zeldovich Effect","title":"Relativistic Sunyaev–Zeldovich Effect","text":"# generate a snapshot of a cluster at a specific frequency\nfunction cluster_snapshot(nu, shape, wcs, y_model_interp, workspace)\n    X = nu_to_X(uconvert(u\"s^-1\",nu))\n    m = Enmap(zeros(shape), wcs);\n\n    # construct a new SZpack object for each frequency; this loads a table from disk.\n    # keep these around if you're looping over multiple maps at fixed frequency\n    model_szp = SZPackRSZProfile(y_model_interp, X)\n\n    paint!(m, workspace, model_szp, [mass_in_Msun], [z], [0.0], [0.0])\n    return m\nend\n\nsnap = cluster_snapshot(500u\"GHz\", shape, wcs, y_model_interp, workspace)\nplot(log10.(snap))","category":"page"},{"location":"rsz/","page":"Relativistic Sunyaev–Zeldovich Effect","title":"Relativistic Sunyaev–Zeldovich Effect","text":"freqs = LinRange(30.0, 800.0, 100) .* u\"GHz\"\nsnaps = [cluster_snapshot(nu, shape, wcs, y_model_interp, workspace) for nu in freqs]\nI_rsz = [snap[i_ctr, j_ctr] * u\"MJy/sr\" for snap in snaps]\nI_tsz = similar(I_rsz)\n\ny0 = tsz_snap[i_ctr, j_ctr]\nfor (i, nu) in enumerate(freqs)\n    X = nu_to_X(nu)\n    I_tsz[i]  = uconvert(u\"MJy/sr\",(X*(ℯ^X + 1)/(ℯ^X - 1) - 4) * y0 * \n        abs((2 * constants.h^2 * nu^4 * ℯ^X) / (\n            constants.k_B * constants.c_0^2 * XGPaint.T_cmb * (ℯ^X - 1)^2)))\nend\n\nplot(freqs, I_tsz, label=\"tSZ\")\nplot!(freqs, I_rsz, label=\"rSZ\")","category":"page"},{"location":"cib/#Cosmic-Infrared-Background-(CIB)","page":"Cosmic Infrared Background","title":"Cosmic Infrared Background (CIB)","text":"","category":"section"},{"location":"cib/","page":"Cosmic Infrared Background","title":"Cosmic Infrared Background","text":"We provide the Planck 2013 CIB model. The following code is a little more verbose than typical Julia code, as one has to repeatedly specify the type Float32 when creating objects. This allows one to more easily fit the entire source catalog into memory.","category":"page"},{"location":"cib/#Tutorial","page":"Cosmic Infrared Background","title":"Tutorial","text":"","category":"section"},{"location":"cib/","page":"Cosmic Infrared Background","title":"Cosmic Infrared Background","text":"using XGPaint, Plots, Pixell\n\n# example , ra and dec in radians, halo mass in M200c (Msun)\nra, dec, redshift, halo_mass = XGPaint.load_example_halos()\n\n# sort\nra, dec, redshift, halo_mass = sort_halo_catalog(ra, dec, redshift, halo_mass)\n\nprint(\"Number of halos: \", length(halo_mass))","category":"page"},{"location":"cib/","page":"Cosmic Infrared Background","title":"Cosmic Infrared Background","text":"Next, we'll generate a cosmology. Note how we use Float32 throughout.","category":"page"},{"location":"cib/","page":"Cosmic Infrared Background","title":"Cosmic Infrared Background","text":"\ncosmo = get_cosmology(h=0.6774f0, OmegaM=0.3075f0)\nx, y, z = XGPaint.ra_dec_redshift_to_xyz(ra, dec, redshift, cosmo)\nhalo_pos = [x'; y'; z';]\n\nmodel = CIB_Planck2013{Float32}()","category":"page"},{"location":"cib/","page":"Cosmic Infrared Background","title":"Cosmic Infrared Background","text":"@time sources = generate_sources(model, cosmo, halo_pos, halo_mass);\nfluxes_cen = Array{Float32, 1}(undef, sources.N_cen)\nfluxes_sat = Array{Float32, 1}(undef, sources.N_sat)\n\nusing Pixell\nbox = [4.5   -4.5;           # RA\n       -3     3] * Pixell.degree  # DEC\nshape, wcs = geometry(CarClenshawCurtis{Float64}, box, 0.5 * Pixell.arcminute)\nm = Enmap(zeros(Float32, shape), wcs)\nXGPaint.paint!(m, 143.0f0 * 1.0f9, model, sources, fluxes_cen, fluxes_sat)\nplot(log10.(m), c=:coolwarm)","category":"page"},{"location":"cib/#Sources-from-HDF5","page":"Cosmic Infrared Background","title":"Sources from HDF5","text":"","category":"section"},{"location":"cib/","page":"Cosmic Infrared Background","title":"Cosmic Infrared Background","text":"To work with the Websky halo catalogs, you can't just use the example catalogs! One first loads the halo positions and masses into memory with read_halo_catalog_hdf5. This package uses halo positions in the shape (3 N_mathrmhalos), where the first dimension is the Cartesian coordinates x y z.","category":"page"},{"location":"cib/","page":"Cosmic Infrared Background","title":"Cosmic Infrared Background","text":"using XGPaint\nusing Healpix\n\n## Load halos from HDF5 files, establish a CIB model and cosmology\nwebsky_directory = \"/global/cfs/cdirs/sobs/www/users/Radio_WebSky\"\nhalo_pos, halo_mass = read_halo_catalog_hdf5(\n    \"$(websky_directory)/websky_halos-light.hdf5\")","category":"page"},{"location":"cib/","page":"Cosmic Infrared Background","title":"Cosmic Infrared Background","text":"Now one specifes the background cosmology with get_cosmology and the source model CIB_Planck2013.","category":"page"},{"location":"cib/","page":"Cosmic Infrared Background","title":"Cosmic Infrared Background","text":"# configuration objects\ncosmo = get_cosmology(Float32; h=0.7, OmegaM=0.25)\nmodel = CIB_Planck2013{Float32}()\n\n# generate sources (healpix pixel, luminosities, etc. \n@time sources = generate_sources(model, cosmo, halo_pos, halo_mass);","category":"page"},{"location":"cib/","page":"Cosmic Infrared Background","title":"Cosmic Infrared Background","text":"This sources is a NamedTuple with arrays for centrals,","category":"page"},{"location":"cib/","page":"Cosmic Infrared Background","title":"Cosmic Infrared Background","text":"hp_ind_cen: healpix index of the central\nlum_cen: luminosity of the central\nredshift_cen: redshift of the central\ndist_cen: distance to the central","category":"page"},{"location":"cib/","page":"Cosmic Infrared Background","title":"Cosmic Infrared Background","text":"There are additionally arrays for the satellites,","category":"page"},{"location":"cib/","page":"Cosmic Infrared Background","title":"Cosmic Infrared Background","text":"hp_ind_sat: healpix index of the satellite\nlum_sat: luminosity of the satellite\nredshift_sat: redshift of the satellite\ndist_sat: distance to the satellite","category":"page"},{"location":"cib/","page":"Cosmic Infrared Background","title":"Cosmic Infrared Background","text":"There are also two integers in sources  for the total number of centrals N_cen and total number of satellites N_sat.","category":"page"},{"location":"cib/#HealpixMap-making","page":"Cosmic Infrared Background","title":"HealpixMap-making","text":"","category":"section"},{"location":"cib/","page":"Cosmic Infrared Background","title":"Cosmic Infrared Background","text":"Once these sources are generated, one needs to create some buffer arrays for map-making. The fluxes of the centrals and satellites are deposited into these arrays, before the map is generated.","category":"page"},{"location":"cib/","page":"Cosmic Infrared Background","title":"Cosmic Infrared Background","text":"# Create some empty arrays for the fluxes to be deposited\nfluxes_cen = Array{Float32, 1}(undef, sources.N_cen)\nfluxes_sat = Array{Float32, 1}(undef, sources.N_sat)\nm = HealpixMap{Float64,RingOrder}(model.nside)  # create a Healpix map","category":"page"},{"location":"cib/","page":"Cosmic Infrared Background","title":"Cosmic Infrared Background","text":"These arrays are used by paint! to create maps. We then save those to disk. We add a time macro to get some info on how long it takes. Note that with NERSC's notoriously slow filesystem, writing to disk can take as long as generating the maps!","category":"page"},{"location":"cib/","page":"Cosmic Infrared Background","title":"Cosmic Infrared Background","text":"for freq in [\"100\", \"143\", \"217\" \"353\", \"545\"]\n    @time paint!(m, parse(Float32, freq) * 1.0f9, model, \n        sources, fluxes_cen, fluxes_sat)\n    saveToFITS(m, \"!/global/cscratch1/sd/xzackli/cib/cib$(freq).fits\")\nend","category":"page"},{"location":"cib/#Custom-Models","page":"Cosmic Infrared Background","title":"Custom Models","text":"","category":"section"},{"location":"cib/","page":"Cosmic Infrared Background","title":"Cosmic Infrared Background","text":"You can make changes while reusing the XGPaint infrastructure by using Julia's multiple dispatch. Create a custom type that inherits from AbstractCIBModel. You must import the function you want to replace, and then write your own version of the function which dispatches on your custom type.","category":"page"},{"location":"cib/","page":"Cosmic Infrared Background","title":"Cosmic Infrared Background","text":" # import AbstractCIBModel and the functions you want to replace\nimport XGPaint: AbstractCIBModel, shang_z_evo \nusing Parameters, Cosmology\n\n# write your own type that is a subtype of AbstractCIBModel\n@with_kw struct CustomCIB{T<:Real} <: AbstractCIBModel{T} @deftype T\n    nside::Int64    = 4096\n    hod::String     = \"shang\"\n    Inu_norm     = 0.3180384\n    min_redshift = 0.0\n    max_redshift = 5.0\n    min_mass     = 1e12\n    box_size     = 40000\n\n    # shang HOD\n    shang_zplat  = 2.0\n    shang_Td     = 20.7\n    shang_beta   = 1.6\n    shang_eta    = 2.4\n    shang_alpha  = 0.2\n    shang_Mpeak  = 10^12.3\n    shang_sigmaM = 0.3\n    shang_Msmin  = 1e11\n    shang_Mmin   = 1e10\n    shang_I0     = 46\n\n    # jiang\n    jiang_gamma_1    = 0.13\n    jiang_alpha_1    = -0.83\n    jiang_gamma_2    = 1.33\n    jiang_alpha_2    = -0.02\n    jiang_beta_2     = 5.67\n    jiang_zeta       = 1.19\nend\n\n# dispatch on custom type CustomCIB. this particular change sets L=0\nfunction shang_z_evo(z::T, model::CustomCIB) where T\n    return zero(T)\nend\n\n# make a cosmology and our custom source model\ncosmo = get_cosmology(Float32; h=0.7, OmegaM=0.3)\ncustom_model = CustomCIB{Float32}()\n\n# for this test, do it only on a subset of the halos\nsources = generate_sources(custom_model, cosmo, halo_pos[:,1:10], halo_mass[1:10])\n\nprint(sources.lum_cen)","category":"page"},{"location":"cib/","page":"Cosmic Infrared Background","title":"Cosmic Infrared Background","text":"This particular change zeros out the luminosities, and indeed you should see the result is an array of zeroes.","category":"page"},{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/#XGPaint.AbstractForegroundModel","page":"API","title":"XGPaint.AbstractForegroundModel","text":"All foreground models inherit from this type.\n\n\n\n\n\n","category":"type"},{"location":"api/#XGPaint.CIB_Planck2013","page":"API","title":"XGPaint.CIB_Planck2013","text":"CIB_Planck2013{T}(; kwargs...)\n\nDefine CIB model parameters. Defaults are from Viero et al. 2013. All numbers not typed are converted to type T. This model has the following parameters and default values:\n\nnside::Int64 = 4096\nmin_redshift = 0.0\nmax_redshift = 5.0\nmin_mass = 1e12\nbox_size = 40000\nshang_zplat = 2.0\nshang_Td = 20.7\nshang_betan = 1.6\nshang_eta = 2.4\nshang_alpha = 0.2\nshang_Mpeak = 10^12.3\nshang_sigmaM = 0.3\nshang_Msmin = 1e11\nshang_Mmin = 1e10\nshang_I0 = 92\njiang_gamma_1 = 0.13\njiang_alpha_1 = -0.83\njiang_gamma_2 = 1.33\njiang_alpha_2 = -0.02\njiang_beta_2 = 5.67\njiang_zeta = 1.19\n\n\n\n\n\n","category":"type"},{"location":"api/#XGPaint.CO_CROWNED","page":"API","title":"XGPaint.CO_CROWNED","text":"CO_CROWNED{T}(; kwargs...)\n\nDefine broadband CO model parameters. All numbers not typed are converted to type T. This model has the following parameters and default values:\n\nnside::Int64 = 4096\nhod::String = \"shang\"\n\n\n\n\n\n","category":"type"},{"location":"api/#XGPaint.LRG_Yuan23","page":"API","title":"XGPaint.LRG_Yuan23","text":"LRG_Yuan23{T}(; kwargs...)\n\nDefine LRG model parameters. Defaults from Yuan et al. 2023 [arXiv:2306.06314]. All numbers not typed are converted to type T. This model has the following parameters and default values:\n\nnside::Int64 = 4096\nhod::String = \"zheng\"\nmin_redshift = 0.0\nmax_redshift = 5.0\nmin_mass = 1e12\nbox_size = 40000\nshang_Msmin = 1e11\nzheng_Mcut = 10^12.7\nzheng_M1 = 10^13.6\nzheng_sigma = 0.2\nzheng_kappa = 0.08\nzheng_alpha = 1.15\nyuan_ic = 0.8\njiang_gamma_1 = 0.13\njiang_alpha_1 = -0.83\njiang_gamma_2 = 1.33\njiang_alpha_2 = -0.02\njiang_beta_2 = 5.67\njiang_zeta = 1.19\n\n\n\n\n\n","category":"type"},{"location":"api/#XGPaint.LogInterpolatorProfile","page":"API","title":"XGPaint.LogInterpolatorProfile","text":"LogInterpolatorProfile{T, P, I1}\n\nA profile that interpolates over a positive-definite function (θ, z, M_halo), but internally interpolates over log(θ) and log10(M) using a given interpolator. Evaluation of this profile is then done by exponentiating the result of the interpolator.\n\n    f(θ, z, M) = exp(itp(log(θ), z, log10(M)))\n\nThis is useful for interpolating over a large range of scales and masses, where the profile is expected to be smooth in log-log space. It wraps the original model and also the  interpolator object itself.\n\n\n\n\n\n","category":"type"},{"location":"api/#XGPaint.Radio_Sehgal2009","page":"API","title":"XGPaint.Radio_Sehgal2009","text":"Radio_Sehgal2009{T}(model parameters...)\n\nDefine CIB model parameters. Defaults are from Viero et al. 2013.\n\nmodel = CIBModel{Float32}(a_0=0.4)\n\n\n\n\n\n","category":"type"},{"location":"api/#XGPaint.P_e_los-NTuple{4, Any}","page":"API","title":"XGPaint.P_e_los","text":"Line-of-sight integrated electron pressure\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.P_th_los-NTuple{4, Any}","page":"API","title":"XGPaint.P_th_los","text":"Line-of-sight integrated thermal pressure\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.SZpack-NTuple{4, Any}","page":"API","title":"XGPaint.SZpack","text":"SZpack(model_szp, θ, M_200, z; showT=false)\n\nOutputs the integrated compton-y signal calculated using SZpack along the line of sight. Note: M_200 requires units.\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.SZpack_rksz-NTuple{6, Any}","page":"API","title":"XGPaint.SZpack_rksz","text":"SZpack_rksz(model, r, M_200, z, vel, mu)\n\nComputes the relativistic kSZ signal using the SZpack tables.\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.T_mass_calc-Union{Tuple{T}, Tuple{XGPaint.AbstractProfile{T}, Any, Any}} where T","page":"API","title":"XGPaint.T_mass_calc","text":"T_mass_calc(model,M,z::T; scale_type=\"Ty\", sim_type=\"combination\") where T\n\nCalculates the temperature for a given halo using https://arxiv.org/pdf/2207.05834.pdf.\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.T_vir_calc-Union{Tuple{T}, Tuple{XGPaint.AbstractProfile{T}, Any, Any}} where T","page":"API","title":"XGPaint.T_vir_calc","text":"T_vir_calc(model, M, z)\n\nCalculates the virial temperature for a given halo using Wang et al. 2007.\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.bl2beam-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractArray}} where T","page":"API","title":"XGPaint.bl2beam","text":"Compute the real-space beam from a harmonic-space beam.\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.build_c_lnm2r_interpolator-Union{Tuple{}, Tuple{T}} where T","page":"API","title":"XGPaint.build_c_lnm2r_interpolator","text":"build_c_lnm2r_interpolator(;cmin::T=1f-3, cmax::T=25.0f0,\n    mmin::T=-7.1f0, mmax::T=0.0f0, nbin=100) where T\n\nGenerate a LinearInterpolation object that turns concentration and ln(M_halo) into satellite radius.\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.build_interpolator-Tuple{XGPaint.AbstractProfile}","page":"API","title":"XGPaint.build_interpolator","text":"Helper function to build a (θ, z, Mh) interpolator\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.build_jiang_interpolator-Union{Tuple{T}, Tuple{T, T, XGPaint.AbstractLRGModel}} where T","page":"API","title":"XGPaint.build_jiang_interpolator","text":"Build a linear interpolation function which maps log(Mh) to Nsh.\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.build_r2z_interpolator-Union{Tuple{T}, Tuple{T, T, Cosmology.AbstractCosmology}} where T","page":"API","title":"XGPaint.build_r2z_interpolator","text":"build_r2z_interpolator(min_z::T, max_z::T,\n    cosmo::Cosmology.AbstractCosmology; n_bins=2000) where T\n\nConstruct a fast r2z linear interpolator.\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.build_shang_interpolator-Union{Tuple{T}, Tuple{T, T, XGPaint.AbstractCIBModel}} where T","page":"API","title":"XGPaint.build_shang_interpolator","text":"Build a linear interpolation function which maps log(Mh) to Nsat.\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.build_z2r_interpolator-Union{Tuple{T}, Tuple{T, T, Cosmology.AbstractCosmology}} where T","page":"API","title":"XGPaint.build_z2r_interpolator","text":"Construct a z2r linear interpolator.\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.build_zhengcen_interpolator-Union{Tuple{T}, Tuple{T, T, XGPaint.AbstractLRGModel}} where T","page":"API","title":"XGPaint.build_zhengcen_interpolator","text":"Build a linear interpolation function which maps log(Mh) to Ncen.\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.build_zhengsat_interpolator-Union{Tuple{T}, Tuple{T, T, XGPaint.AbstractLRGModel}} where T","page":"API","title":"XGPaint.build_zhengsat_interpolator","text":"Build a linear interpolation function which maps log(Mh) to Nsat.\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.chunk-Tuple{Any, Integer}","page":"API","title":"XGPaint.chunk","text":"Generates a list of tuples which describe starting and ending chunk indices. Useful for parallelizing an array operation.\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.cleanup_negatives!-Tuple{Any}","page":"API","title":"XGPaint.cleanup_negatives!","text":"prune a profile grid for negative values, extrapolate instead\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.compton_y-Tuple{Battaglia16ThermalSZProfile, Any, Any, Any}","page":"API","title":"XGPaint.compton_y","text":"compton_y(model, r, M_200c, z)\n\nCalculate the Compton y parameter for a given model at a given radius, mass, and redshift. Mass needs to have units!\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.ellpad-Union{Tuple{Array{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"API","title":"XGPaint.ellpad","text":"Utility function which prepends some zeros to an array. It makes a copy instead of modifying the input.\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.fquench_UM-Union{Tuple{T}, Tuple{T, T, XGPaint.AbstractCIBModel}} where T","page":"API","title":"XGPaint.fquench_UM","text":"Quiescent fraction recipe from UniverseMachine\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.generate_sources-Union{Tuple{TH}, Tuple{T}, Tuple{XGPaint.AbstractCIBModel{T}, Cosmology.FlatLCDM{T}, AbstractMatrix{TH}, AbstractVector{TH}}} where {T, TH}","page":"API","title":"XGPaint.generate_sources","text":"generate_sources(model, cosmo, halo_pos_inp, halo_mass_inp; verbose=true)\n\nProduce a source catalog from a model and halo catalog. This converts the halo arrays into the type specified by model.\n\nArguments:\n\nmodel::AbstractCIBModel{T}: source model parameters\ncosmo::Cosmology.FlatLCDM{T}: background cosmology\nHealpix_res::Resolution: Healpix map resolution\nhalo_pos_inp::AbstractArray{TH,2}: halo positions with dims (3, nhalos)\nhalo_mass_inp::AbstractArray{TH,1}: halo masses\n\nKeywords\n\nverbose::Bool=true: print out progress details\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.generate_sources-Union{Tuple{TH}, Tuple{T}, Tuple{XGPaint.AbstractLRGModel{T}, Cosmology.FlatLCDM{T}, AbstractMatrix{TH}, AbstractVector{TH}, AbstractVector{TH}}} where {T, TH}","page":"API","title":"XGPaint.generate_sources","text":"generate_sources(model, cosmo, halo_pos_inp, halo_mass_inp; verbose=true)\n\nProduce a source catalog from a model and halo catalog. This converts the halo arrays into the type specified by model.\n\nArguments:\n\nmodel::AbstractCIBModel{T}: source model parameters\ncosmo::Cosmology.FlatLCDM{T}: background cosmology\nHealpix_res::Resolution: Healpix map resolution\nhalo_pos_inp::AbstractArray{TH,2}: halo positions with dims (3, nhalos)\nhalo_mass_inp::AbstractArray{TH,1}: halo masses\n\nKeywords\n\nverbose::Bool=true: print out progress details\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.generate_sources-Union{Tuple{TH}, Tuple{T}, Tuple{XGPaint.AbstractRadioModel{T}, Cosmology.FlatLCDM{T}, AbstractMatrix{TH}, AbstractVector{TH}}} where {T, TH}","page":"API","title":"XGPaint.generate_sources","text":"Produce a source catalog from a model and halo catalog.\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.generate_subhalo_offsets-Tuple{Any}","page":"API","title":"XGPaint.generate_subhalo_offsets","text":"Generate an array where the value at index i corresponds to the index of the first source of halo i. Takes an array where the value at index i corresponds to the number of subhalos that halo i has.\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.get_angles-Union{Tuple{Matrix{T}}, Tuple{T}} where T","page":"API","title":"XGPaint.get_angles","text":"Compute angles of halos\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.get_basic_halo_properties-Union{Tuple{T}, Tuple{Matrix{T}, XGPaint.AbstractForegroundModel, Cosmology.FlatLCDM{T}, Resolution}} where T","page":"API","title":"XGPaint.get_basic_halo_properties","text":"Fill in basic halo properties.\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.get_cosmology-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"API","title":"XGPaint.get_cosmology","text":"get_cosmology(::Type{T}; h=0.69, Neff=3.04, OmegaK=0.0,\n    OmegaM=0.29, OmegaR=nothing, Tcmb=2.7255, w0=-1, wa=0)\n\nConstruct a background cosmology. This function duplicates the cosmology() function in Cosmology.jl, but with the numeric type specified.\n\nArguments:\n\n::Type{T}: numerical type to use for calculations\n\nKeywords\n\nh - Dimensionless Hubble constant\nOmegaK - Curvature density (Ω_k)\nOmegaM - Matter density (Ω_m)\nOmegaR - Radiation density (Ω_r)\nTcmb - CMB temperature in Kelvin; used to compute Ω_γ\nNeff - Effective number of massless neutrino species; used to compute Ω_ν\nw0 - CPL dark energy equation of state; w = w0 + wa(1-a)\nwa - CPL dark energy equation of state; w = w0 + wa(1-a)\n\nExample\n\njulia> get_cosmology(Float32; h=0.7)\nCosmology.FlatLCDM{Float32}(0.7f0, 0.7099147f0, 0.29f0, 8.5307016f-5)\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.get_interpolators-Union{Tuple{T}, Tuple{CIB_Planck2013, Cosmology.FlatLCDM{T}, T, T}} where T","page":"API","title":"XGPaint.get_interpolators","text":"Construct the necessary interpolator set.\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.get_interpolators-Union{Tuple{T}, Tuple{XGPaint.AbstractLRGModel, Cosmology.FlatLCDM{T}, T, T}} where T","page":"API","title":"XGPaint.get_interpolators","text":"Construct the necessary interpolator set.\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.get_ring_disc_ranges-Union{Tuple{T}, Tuple{HealpixRingProfileWorkspace{T}, Int64, T, T, T}} where T","page":"API","title":"XGPaint.get_ring_disc_ranges","text":"get_ring_disc_ranges(workspace, ring_idx, θ_center, ϕ_center, radius)\n\nReturns (range1, range2) of pixel indices on a ring that lie within the disc.\n\nThe spherical distance between points (θ₁,φ₁) and (θ₂,φ₂) is given by:     cos(d) = cos(θ₁)cos(θ₂) + sin(θ₁)sin(θ₂)cos(φ₁ - φ₂)\n\nFor a point to be included in the disc: d ≤ radius.\n\nReturns two ranges to handle φ wraparound at the 0/2π boundary:\n\nrange1: Main contiguous range of pixels  \nrange2: Additional range when disc crosses φ=0/2π seam (empty if no crossing)\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.hod_sehgal-Union{Tuple{T}, Tuple{Any, Any, Radio_Sehgal2009{T}}} where T","page":"API","title":"XGPaint.hod_sehgal","text":"Populate halos with radio sources according to the HOD in Sehgal et al. 2009.\n\nThe optional rng parameter provides an array of random number generators, one for each thread.\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.l2f-Union{Tuple{T}, Tuple{T, T, T}} where T","page":"API","title":"XGPaint.l2f","text":"Inverse square law with redshift dependence.\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.load_example_halos-Tuple{}","page":"API","title":"XGPaint.load_example_halos","text":"Reads a collection of example halos out of the WebSky halo catalogs, and returns  RA (rad), DEC (rad), redshift, and halo mass (M200c).\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.load_precomputed_battaglia-Tuple{}","page":"API","title":"XGPaint.load_precomputed_battaglia","text":"Reads in a standard Battaglia 2016 model from disk for tSZ.\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.m2r-Union{Tuple{T}, Tuple{T, Cosmology.FlatLCDM{T}}} where T","page":"API","title":"XGPaint.m2r","text":"m2r(m::T, cosmo::Cosmology.FlatLCDM{T}) where T\n\nConvert virial mass to virial radius.\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.mz2c-Union{Tuple{T}, Tuple{T, T, Cosmology.FlatLCDM{T}}} where T","page":"API","title":"XGPaint.mz2c","text":"mz2c(m::T, z::T, cosmo::Cosmology.FlatLCDM{T}) where T\n\nCompute concentration factor from Duffy et al. 2008.\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.paint!-Union{Tuple{T}, Tuple{HealpixMap{T, RingOrder, AA} where AA<:AbstractVector{T}, T, XGPaint.AbstractCIBModel, Any}} where T","page":"API","title":"XGPaint.paint!","text":"Paint a source catalog onto a map.\n\nThis function creates the arrays for you.\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.paint!-Union{Tuple{T}, Tuple{T_map}, Tuple{HealpixMap{T_map, RingOrder, AA} where AA<:AbstractVector{T_map}, Any, XGPaint.AbstractCIBModel{T}, Any, AbstractArray, AbstractArray}} where {T_map, T}","page":"API","title":"XGPaint.paint!","text":"paint!(result_map, nu_obs, model, sources, fluxes_cen, fluxes_sat)\n\nPaint a source catalog onto a map, recording the fluxes in fluxes_cen and fluxes_sat.\n\nArguments:\n\nresult_map::HealpixMap{T_map, RingOrder}: Healpix map to paint\nnu_obs: frequency in Hz\nmodel::AbstractCIBModel{T}: source model parameters\nsources: NamedTuple containing source information from generate_sources\nfluxes_cen::AbstractArray: buffer for writing fluxes of centrals\nfluxes_sat::AbstractArray: buffer for writing fluxes of satellites\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.paint!-Union{Tuple{T}, Tuple{T_map}, Tuple{HealpixMap{T_map, RingOrder, AA} where AA<:AbstractVector{T_map}, XGPaint.AbstractLRGModel{T}, Any, T, T}} where {T_map, T}","page":"API","title":"XGPaint.paint!","text":"paint!(result_map, model, sources, min_redshift, max_redshift)\n\n'Paint' the LRG catalog onto a map.\n\nArguments:\n\nresult_map::HealpixMap{T_map, RingOrder}: Healpix map to paint\nmodel::AbstractCIBModel{T}: source model parameters\nsources: NamedTuple containing source information from generate_sources\nfluxes_cen::AbstractArray: buffer for writing fluxes of centrals\nfluxes_sat::AbstractArray: buffer for writing fluxes of satellites\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.rSZ_perturbative-NTuple{4, Any}","page":"API","title":"XGPaint.rSZ_perturbative","text":"rSZ_perturbative(model, r, M_200, z; T_scale=\"virial\", sim_type=\"combination\", showT=true)\n\nCalculates the integrated relativistic compton-y signal along the line of sight. Mass  requires units.\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.ra_dec_redshift_to_xyz-Union{Tuple{T}, Tuple{Any, Any, Any, Cosmology.FlatLCDM{T}}} where T","page":"API","title":"XGPaint.ra_dec_redshift_to_xyz","text":"Convert RA (rad), DEC (rad), and redshift to xyz comoving radial dist.\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.read_halo_catalog_hdf5-Tuple{Any}","page":"API","title":"XGPaint.read_halo_catalog_hdf5","text":"Utility function to read an HDF5 table with x, y, z, M_h as the four rows. The hdf5 record is \"halos\".\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.realspacegaussbeam-Union{Tuple{Ti}, Tuple{T}, Tuple{Type{T}, Ti}} where {T, Ti}","page":"API","title":"XGPaint.realspacegaussbeam","text":"Computes a real-space beam interpolator and a maximum\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.rsz_szpack_table_filename-Tuple{}","page":"API","title":"XGPaint.rsz_szpack_table_filename","text":"Returns a stored artifact: a precomputed SZpack table\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.sehgal_LF!-Union{Tuple{T}, Tuple{Vector{T}, Any, Any, T, Any, Vector{T}}} where T","page":"API","title":"XGPaint.sehgal_LF!","text":"Fills the result array with draws from the luminosity function.\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.transform_profile_grid!-Tuple{Any, Any, Any}","page":"API","title":"XGPaint.transform_profile_grid!","text":"Apply a beam to a profile grid\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.vectorhealpixmap-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T","page":"API","title":"XGPaint.vectorhealpixmap","text":"vecmap([T=Float64], nside::Int)\n\nGenerate a map of 3-tuples, showing the (x,y,z) values of the points on the unit 2-sphere for a Healpix map.\n\n\n\n\n\n","category":"method"},{"location":"api/#XGPaint.z_evo-Union{Tuple{T}, Tuple{T, CIB_Planck2013}} where T","page":"API","title":"XGPaint.z_evo","text":"Compute redshift evolution factor for LF.\n\n\n\n\n\n","category":"method"},{"location":"sz/#The-Sunyaev–Zeldovich-Effect","page":"Sunyaev–Zeldovich Effect","title":"The Sunyaev–Zeldovich Effect","text":"","category":"section"},{"location":"sz/","page":"Sunyaev–Zeldovich Effect","title":"Sunyaev–Zeldovich Effect","text":"Let's make some maps of the thermal Sunyaev-Zeldovich (SZ) effect. First, let's load up the example halo catalog included in this package. These will be automatically downloaded the first time you load them.","category":"page"},{"location":"sz/","page":"Sunyaev–Zeldovich Effect","title":"Sunyaev–Zeldovich Effect","text":"using XGPaint, Plots\n\n# example , ra and dec in radians, halo mass in M200c (Msun)\nra, dec, redshift, halo_mass = XGPaint.load_example_halos()\nprint(\"Number of halos: \", length(halo_mass))","category":"page"},{"location":"sz/","page":"Sunyaev–Zeldovich Effect","title":"Sunyaev–Zeldovich Effect","text":"This small catalog is limited to a relatively small patch of the sky. Before we generate some SZ maps, let's take a look at the halo mass distribution.","category":"page"},{"location":"sz/","page":"Sunyaev–Zeldovich Effect","title":"Sunyaev–Zeldovich Effect","text":"b = 10.0 .^ (11:0.25:16)\nhistogram(halo_mass, bins=b, xaxis=(:log10, (1e11, 1e16)), \n    yscale=:log10, label=\"\", xlabel=\"Halo mass (solar masses)\", ylabel=\"counts\")","category":"page"},{"location":"sz/","page":"Sunyaev–Zeldovich Effect","title":"Sunyaev–Zeldovich Effect","text":"Also notice the steep dropoff in counts at 10^12 M_odot, corresponding to the halo resolution of the Websky simulation from which these halos were taken. Fortunately, the SZ effect is dominated by the most massive halos.","category":"page"},{"location":"sz/","page":"Sunyaev–Zeldovich Effect","title":"Sunyaev–Zeldovich Effect","text":"To allow for safe threaded painting on a single map, we'll sort the halo catalog by declinations.","category":"page"},{"location":"sz/","page":"Sunyaev–Zeldovich Effect","title":"Sunyaev–Zeldovich Effect","text":"ra, dec, redshift, halo_mass = sort_halo_catalog(ra, dec, redshift, halo_mass);","category":"page"},{"location":"sz/","page":"Sunyaev–Zeldovich Effect","title":"Sunyaev–Zeldovich Effect","text":"This package relies on a precomputed interpolation table for performance when making large sky maps of the SZ effect. For this tutorial, we'll load a profile and the associated interpolator from disk.","category":"page"},{"location":"sz/","page":"Sunyaev–Zeldovich Effect","title":"Sunyaev–Zeldovich Effect","text":"y_model_interp = XGPaint.load_precomputed_battaglia()\nprint(y_model_interp)","category":"page"},{"location":"sz/","page":"Sunyaev–Zeldovich Effect","title":"Sunyaev–Zeldovich Effect","text":"note: Note\nIf you want to generate your own model (such as varying cosmology), you would instead configure the appropriate model and then build an interpolator. The interpolator generation is multithreaded and takes about five minutes on 16 cores. y_model = Battaglia16ThermalSZProfile(Omega_c=0.2589, Omega_b=0.0486, h=0.6774)\ny_model_interp = build_interpolator(y_model, cache_file=\"cached_b16.jld2\", overwrite=true)This will save the results to the cache_file as well. If you want to load a result from disk, you can specify overwrite=false[1].","category":"page"},{"location":"sz/","page":"Sunyaev–Zeldovich Effect","title":"Sunyaev–Zeldovich Effect","text":"[1]: For maps with many pixels and halos, building the interpolator is only about 10% of the map generation cost. If you have a use case where you instead need to vary cosmology on very small patches, contact the developers!","category":"page"},{"location":"sz/","page":"Sunyaev–Zeldovich Effect","title":"Sunyaev–Zeldovich Effect","text":"Now, we'll set up the map to generate. We will construct a small CAR (Clenshaw-Curtis variant) patch on the sky. You have to construct a workspace for each new sky patch.","category":"page"},{"location":"sz/","page":"Sunyaev–Zeldovich Effect","title":"Sunyaev–Zeldovich Effect","text":"using Pixell\nbox = [4.5   -4.5;           # RA\n       -3     3] * Pixell.degree  # DEC\nshape, wcs = geometry(CarClenshawCurtis{Float64}, box, 0.5 * Pixell.arcminute)\nm = Enmap(zeros(shape), wcs)\n\n# construct on workspace on this patch\nworkspace = profileworkspace(shape, wcs)","category":"page"},{"location":"sz/","page":"Sunyaev–Zeldovich Effect","title":"Sunyaev–Zeldovich Effect","text":"Now it's time to apply the model to the map.","category":"page"},{"location":"sz/","page":"Sunyaev–Zeldovich Effect","title":"Sunyaev–Zeldovich Effect","text":"@time paint!(m, workspace, y_model_interp, halo_mass, redshift, ra, dec)\nplot(log10.(m), c = :thermal)","category":"page"},{"location":"sz/#Healpix","page":"Sunyaev–Zeldovich Effect","title":"Healpix","text":"","category":"section"},{"location":"sz/","page":"Sunyaev–Zeldovich Effect","title":"Sunyaev–Zeldovich Effect","text":"To generate Healpix maps, you'll need the Healpix.jl package.","category":"page"},{"location":"sz/","page":"Sunyaev–Zeldovich Effect","title":"Sunyaev–Zeldovich Effect","text":"using Healpix\nusing XGPaint\n\nnside = 4096\nm_hp = HealpixMap{Float64,RingOrder}(nside)\nres = Healpix.Resolution(nside)\nw = HealpixRingProfileWorkspace{Float64}(res)\n@time paint!(m_hp, w, y_model_interp, halo_mass, redshift, ra, dec)\n# Healpix.saveToFITS(m_hp, \"!y.fits\", typechar=\"D\")  # to save, uncomment\n\nplot(m_hp)","category":"page"},{"location":"developer_notes/#Developer-Notes","page":"Developer Notes","title":"Developer Notes","text":"","category":"section"},{"location":"developer_notes/","page":"Developer Notes","title":"Developer Notes","text":"If you're new to the Julia language, my favorite tutorial is this Introduction to Julia for Quantitative Economics. Sections 1-13 are the most relevant if you are an astronomer, but some of later numerical techniques can also be useful. Computing clusters will often have a Julia module; make sure you load a Julia version 1.6 or later. ","category":"page"},{"location":"developer_notes/","page":"Developer Notes","title":"Developer Notes","text":"For your development computer, download the precompiled binaries and add the Julia executable to your $PATH. Do not use a package manager to install Julia. The Julia compiler has a heavily modified glibc, which many package managers misconfigure (such as the AUR). Rust also faces this problem.","category":"page"},{"location":"developer_notes/#Package-development","page":"Developer Notes","title":"Package development","text":"","category":"section"},{"location":"developer_notes/","page":"Developer Notes","title":"Developer Notes","text":"To make changes to this package, start up the Julia interpeter and run","category":"page"},{"location":"developer_notes/","page":"Developer Notes","title":"Developer Notes","text":"julia> ] dev git@github.com:WebSky-CITA/XGPaint.jl.git","category":"page"},{"location":"developer_notes/","page":"Developer Notes","title":"Developer Notes","text":"By default, this will place a copy of this package's repository in your home directory, ~/.julia/dev/XGPaint. Changes to the code in this folder will be reflected in your global environment.","category":"page"},{"location":"developer_notes/","page":"Developer Notes","title":"Developer Notes","text":"It can be helpful to write documentation alongside a live preview. This is accomplished with the LiveServer package.  You should install the LiveServer and Documenter packages. If you have a standard Julia installlation, you can run from the command line,","category":"page"},{"location":"developer_notes/","page":"Developer Notes","title":"Developer Notes","text":"cd $HOME/.julia/dev/XGPaint\njulia --project=. -e \"using XGPaint, LiveServer; servedocs()\"","category":"page"},{"location":"developer_notes/","page":"Developer Notes","title":"Developer Notes","text":"This will render HTML pages and provide an HTTP server for local previews. The documentation will automatically update when you make changes.","category":"page"},{"location":"ksz/#The-Kinetic-Sunyaev–Zeldovich-Effect","page":"Kinetic Sunyaev–Zeldovich Effect","title":"The Kinetic Sunyaev–Zeldovich Effect","text":"","category":"section"},{"location":"ksz/","page":"Kinetic Sunyaev–Zeldovich Effect","title":"Kinetic Sunyaev–Zeldovich Effect","text":"Let's make some maps of the kinetic Sunyaev-Zeldovich (SZ) effect. First, let's load up the example halo catalog included in this package. These will be automatically downloaded the first time you load them.","category":"page"},{"location":"ksz/","page":"Kinetic Sunyaev–Zeldovich Effect","title":"Kinetic Sunyaev–Zeldovich Effect","text":"using XGPaint, Plots, Unitful, UnitfulAstro\n\n# example , ra and dec in radians, halo mass in M200c (Msun)\nra, dec, redshift, halo_mass = XGPaint.load_example_halos()\nprint(\"Number of halos: \", length(halo_mass))\n\n# the current test halos do not include velocities, so we randomly generate some for this\nproj_v_over_c = randn(eltype(ra), length(halo_mass)) / 1000","category":"page"},{"location":"ksz/","page":"Kinetic Sunyaev–Zeldovich Effect","title":"Kinetic Sunyaev–Zeldovich Effect","text":"This small catalog is limited to a relatively small patch of the sky. Before we generate some SZ maps, let's take a look at the halo mass distribution.","category":"page"},{"location":"ksz/","page":"Kinetic Sunyaev–Zeldovich Effect","title":"Kinetic Sunyaev–Zeldovich Effect","text":"b = 10.0 .^ (11:0.25:16)\nhistogram(halo_mass, bins=b, xaxis=(:log10, (1e11, 1e16)), \n    yscale=:log10, label=\"\", xlabel=\"Halo mass (solar masses)\", ylabel=\"counts\")","category":"page"},{"location":"ksz/","page":"Kinetic Sunyaev–Zeldovich Effect","title":"Kinetic Sunyaev–Zeldovich Effect","text":"To allow for safe threaded painting on a single map, we'll sort the halo catalog by declinations.","category":"page"},{"location":"ksz/","page":"Kinetic Sunyaev–Zeldovich Effect","title":"Kinetic Sunyaev–Zeldovich Effect","text":"ra, dec, redshift, halo_mass = sort_halo_catalog(ra, dec, redshift, halo_mass);","category":"page"},{"location":"ksz/","page":"Kinetic Sunyaev–Zeldovich Effect","title":"Kinetic Sunyaev–Zeldovich Effect","text":"Now, we'll set up the map to generate. We will construct a small CAR (Clenshaw-Curtis variant) patch on the sky. You have to construct a workspace for each new sky patch.","category":"page"},{"location":"ksz/","page":"Kinetic Sunyaev–Zeldovich Effect","title":"Kinetic Sunyaev–Zeldovich Effect","text":"using Pixell\nbox = [4.5   -4.5;           # RA\n       -3     3] * Pixell.degree  # DEC\nshape, wcs = geometry(CarClenshawCurtis{Float64}, box, 0.5 * Pixell.arcminute)\nm = Enmap(zeros(shape), wcs)","category":"page"},{"location":"ksz/","page":"Kinetic Sunyaev–Zeldovich Effect","title":"Kinetic Sunyaev–Zeldovich Effect","text":"Now let's set up an electron profile.","category":"page"},{"location":"ksz/","page":"Kinetic Sunyaev–Zeldovich Effect","title":"Kinetic Sunyaev–Zeldovich Effect","text":"model = BattagliaTauProfile(Omega_c=0.267, Omega_b=0.0493,  h=0.6712)","category":"page"},{"location":"ksz/","page":"Kinetic Sunyaev–Zeldovich Effect","title":"Kinetic Sunyaev–Zeldovich Effect","text":"We can now compute the integrated electron density, ","category":"page"},{"location":"ksz/","page":"Kinetic Sunyaev–Zeldovich Effect","title":"Kinetic Sunyaev–Zeldovich Effect","text":"workspace = profileworkspace(shape, wcs)\n\n# this only needs to be done once\n# to DIY: interp = build_interpolator(model, cache_file=\"cached_btau.jld2\", overwrite=true)\nmodel_interp = XGPaint.load_precomputed_battaglia_tau()\n\nm = Enmap(zeros(shape), wcs)\npaint!(m, workspace, model_interp, halo_mass, redshift, ra, dec, proj_v_over_c)\nplot(log10.(abs.(m)), c = :thermal)","category":"page"},{"location":"ksz/#Healpix","page":"Kinetic Sunyaev–Zeldovich Effect","title":"Healpix","text":"","category":"section"},{"location":"ksz/","page":"Kinetic Sunyaev–Zeldovich Effect","title":"Kinetic Sunyaev–Zeldovich Effect","text":"To generate Healpix maps, you'll need the Healpix.jl package.","category":"page"},{"location":"ksz/","page":"Kinetic Sunyaev–Zeldovich Effect","title":"Kinetic Sunyaev–Zeldovich Effect","text":"using Healpix\nusing XGPaint\n\nnside = 2048\nm_hp = HealpixMap{Float64,RingOrder}(nside)\nres = Healpix.Resolution(nside)\nw = HealpixRingProfileWorkspace{Float64}(res)\n\n@time paint!(m_hp, w, model_interp, halo_mass, redshift, ra, dec, proj_v_over_c)\n# Healpix.saveToFITS(m_hp, \"!y.fits\", typechar=\"D\")  # to save, uncomment\n\nplot(m_hp)","category":"page"},{"location":"#XGPaint","page":"Home","title":"XGPaint","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"XGPaint paints maps of extragalactic foregrounds using halo models. We provide CIB and radio models. The CIB model is described in the Websky paper, Stein et al. 2020. The radio model is from Li et al. 2021, a paper in prep for the Websky suite, and is derived from Sehgal et al. 2009.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The general workflow is:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Read halos\nSpecify a background cosmology and source model\nUse the model to put sources in halos\nPut the sources on maps","category":"page"}]
}
